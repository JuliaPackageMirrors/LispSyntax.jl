{"name":"Lispsyntax.jl","tagline":"lisp-like syntax for julia","body":"LispSyntax.jl: A clojure-like lisp syntax for julia\r\n===================================================\r\n\r\n[![Join the chat at https://gitter.im/swadey/LispSyntax.jl](https://badges.gitter.im/swadey/LispSyntax.jl.svg)](https://gitter.im/swadey/LispSyntax.jl?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n![Build Status](https://travis-ci.org/swadey/LispSyntax.jl.svg?branch=master)\r\n\r\nThis package provides a julia-to-lisp syntax translator with\r\nconvenience macros that let you do this: \r\n\r\n```julia \r\nlisp\"(defn fib [a] (if (< a 2) a (+ (fib (- a 1)) (fib (- a 2)))))\" \r\n@test lisp\"(fib 30)\" == 832040 \r\n@test fib(30)        == 832040 \r\n```\r\n\r\nLispSyntax.jl is implemented as an expression translator between\r\nlisp/clojure-like syntax and julia's AST.  Julia's compiler, JIT and\r\nmultiple-dispatch infrastructure is used for code generation and\r\nexecution. Because of this, LispSyntax.jl is not really clojure or lisp in\r\nmost meaningful ways.  The semantics are entirely julia-based (which\r\nare very similar to scheme/lisp in many ways).  The net result is that\r\nLispSyntax.jl is really an alternative S-expression-like syntax for julia,\r\nnot an implemention of clojure or lisp.\r\n\r\nSpecial Forms\r\n-------------\r\n\r\n- `(def symbol init)`\r\n- `(quote form)`\r\n- `(defn symbol [param*] expr*)`\r\n- `(defmacro symbol [param*] expr*)`\r\n- `(lambda [param*] expr*)``\r\n- `(fn [param*] expr*)``\r\n- `(let [binding*] expr*)`\r\n- `(global symbol*)`\r\n- `(while test expr*)`\r\n- `(for [binding*] expr*)`\r\n- `(import package*)`\r\n\r\n\r\nNotable Differences\r\n-------------------\r\n\r\n- *Symbol names cannot have -, \\*, /, ? ...* - Julia symbol naming is used for\r\n   everything, as a result, Julia syntax restrictions are maintained\r\n   in `LispSyntax.jl`.\r\n- *Reference to global variables in function scopes* - Julia requires\r\n   declaration of global symbols that are referenced in function\r\n   scope.  Because of this functions need to declare which symbols are\r\n   global.  This is done via the special form `(global symbol*)`.\r\n- *Binding forms not implemented* - Clojure has very awesome\r\n   destructuring binds that can used in most special forms requiring\r\n   bindings (e.g. `let`, `fn` parameter lists, etc.).  This is not\r\n   currently implemented.\r\n- *Lack of loop/recur* - Currently, this is not implemented.  As with\r\n   Clojure, julia does not currently support TCO, so something like\r\n   this may be needed (but a macro-implementation of tail call rewriting may be\r\n   more appropriate for julia).\r\n- *Optional typing* - Currently not implemented.\r\n- *Method definition* - Also not currently implemented.  If\r\n   implemented it will probably not be a full implementation of\r\n   Clojure's sophisticated dispatch system.\r\n- *Macros differences* - Macros defined in `LispSyntax.jl` look like\r\n   standard Lisp macros but because expressions are special objects in\r\n   julia, S-expressions returned from macros require a special\r\n   translation step to generate julia expression trees.  The result is\r\n   that `LispSyntax.jl` macros are directly translated into Julia macros and\r\n   must be called via special syntax (e.g. `(@macro expr)`).\r\n- *Julia's string macro dispatch not supported (yet)* - for macros\r\n   like `@r_str` which in Julia can be called via `r\"\"`, it is\r\n   currently necessary to call these via standard macro syntax:\r\n   `(@r_str \"string\")`\r\n\r\nTODO\r\n----\r\n\r\n- Support for exceptions: this is straight forward but not currently implemented.\r\n- Optional typing to support method definition\r\n- Structs and aggregate types\r\n- Special dispatch for string macro forms\r\n- Modules\r\n- import vs. using vs. include -- only `using` is currently\r\n  implemented and confusingly, it matches Clojure's import form.\r\n- varargs and named arguments\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}